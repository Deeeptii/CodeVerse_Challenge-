// Comparison function for sorting intervals  
int compareIntervals(const void* a, const void* b) {  
    int* interval1 = *(int**)a;  
    int* interval2 = *(int**)b;  
    return interval1[0] - interval2[0];  
}  

int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes) {  
    // Handle empty input  
    if (intervalsSize == 0) {  
        *returnSize = 0;  
        *returnColumnSizes = NULL;  
        return NULL;  
    }  
    
    // Sort intervals based on start times  
    qsort(intervals, intervalsSize, sizeof(int*), compareIntervals);  
    
    // Allocate memory for result  
    int** result = (int**)malloc(intervalsSize * sizeof(int*));  
    *returnColumnSizes = (int*)malloc(intervalsSize * sizeof(int));  
    
    // Initialize first interval  
    result[0] = (int*)malloc(2 * sizeof(int));  
    result[0][0] = intervals[0][0];  
    result[0][1] = intervals[0][1];  
    *returnSize = 1;  
    
    // Merge intervals  
    for (int i = 1; i < intervalsSize; i++) {  
        int* lastMerged = result[*returnSize - 1];  
        
        // Check for overlap  
        if (intervals[i][0] <= lastMerged[1]) {  
            // Merge overlapping intervals  
            lastMerged[1] = fmax(lastMerged[1], intervals[i][1]);  
        } else {  
            // Add new non-overlapping interval  
            result[*returnSize] = (int*)malloc(2 * sizeof(int));  
            result[*returnSize][0] = intervals[i][0];  
            result[*returnSize][1] = intervals[i][1];  
            (*returnSize)++;  
        }  
    }  
    
    // Set column sizes  
    for (int i = 0; i < *returnSize; i++) {  
        (*returnColumnSizes)[i] = 2;  
    }  
    
    return result;  
}  
